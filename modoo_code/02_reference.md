# 2. reference

### 참조자의 도입

```c++
#include <iostream>

int change_val(int *p) {
  *p = 3;
  return 0;
}

int main() {
  int number = 5;

  std::cout << number << std::endl;
  change_val(&number);
  std::cout << number << std::endl;
}
```

위 함수를 실행하면 다음과 같은 결과가 나올 것이다.

```shell
5
3
```

위처럼 C에선 어떠한 변수를 가리킬 때, 반드시 포인터를 사용해야 했다.
그러나 C++에선 변수나 상수를 가리키는 다른 방법을 제공하는데 이를 **참조자(reference)** 라고 부른다.

```c++
#include <iostream>

int main() {
  int a = 3;
  int& another_a = a;

  another_a = 5;
  std::cout << "a : " << a << std::endl;
  std::cout << "another_a : " << another_a << std::endl;

  return 0;
}
```

위 함수를 실행시키면 다음과 같은 결과가 나온다.

```shell
a : 5
another_a : 5 
```

위 코드를 천천히 살펴보면 먼저 변수 `a`를 정의하고 3을 대입했다.
그리고 참조자 `another_a` 를 정의했다. 

이때, 참조자를 정의하는 방법은 가리키고자 하는 타입 뒤에 `&`을 붙이는 것이다.
`int` 형의 참조자는 `int&`, `int*` 형의 참조자는 `int*&` 로 쓰면 된다.

위 코드를 통해 컴파일러는 `another_a` 는 `a` 의 또 다른 이름이라고 알게 된다.
그렇기에 `another_a` 에 수행하는 어떠한 작업도 사실상 `a` 에게 작업하는 것과 마찬가지다.

이렇듯, 참조자는 포인터와 유사한 부분이 있다. 포인터 역시 어떤 변수의 주소값을 보관함으로써 해당 변수에 간접적으로 연산이 가능하기 떄문이다. 
하지만 몇 가지 중요한 차이점 역시 있다.

#### 레퍼런스는 반드시 처음에 누구의 별명이 될 것인지 지정행야 한다.

레퍼런스는 정의 시에 반드시 누구의 별명이 될 것인지 명시해야 한다.

```c++
int& another_a; // 불가능
int* p;         // 가능
```

그렇기에 위와 같은 문장은 불가능하다. 허나 포인터는 가능하다.

#### 레퍼런스는 한 번 별명이 되면 절대로 다른 이의 별명이 될 수 없다.

레퍼런스는 어떤 변수의 레퍼런스가 되버리면, 더 이상 다른 변수를 참조할 수 없다.

```c++
int a = 10;
int &another_a = a;

int b = 3;
another_a = b;
```

만약 위와 같은 코드를 실행시킨다면 `another_a` 가 `b` 를 가리키는 것이 아니다.
그냥 `a` 에 `b` 를 대입시키라는 의미이다. 사실상 `a` 와 같다고 봐야 한다.

참고로 `&another_a = b;` 와 같은 코드는 `&a=b;` 와 같은 의미라서 문법적으로 틀리다.

반면에 포인터는 자신이 가리킬 대상을 자유롭게 바꿀 수 있다.

#### 레퍼런스는 메모리 상에 존재하지 않을 수도 있다.

포인터는 선언한다면 메모리 상에서 8바이트를 차지한다. (물론 32비트 시스템에선 4바이트입니다.)

허나 레퍼런스는 조금 다르다. 왜냐하면 레퍼런스가 쓰이는 모든 곳을 가리키고 있는 변수로 바꿔치기 하면 되기 때문이다.
그렇기에 레퍼런스는 메모리 상에 존재하지 않는다.

하지만 레퍼런스가 항상 메모리 상에 존재하지 않는 것은 아니다.

### 함수 인자로 레퍼런스 받기

```c++
#include <iostream>

int change_val(int &p) {
  p = 3;

  return 0;
}
int main() {
  int number = 5;

  std::cout << number << std::endl;
  change_val(number);
  std::cout << number << std::endl;
}
```

```shell
# 실행 결과
5
3
```

위 코드는 레퍼런스를 이용해서 `number` 를 `change_val` 의 매개변수로 넣은 것이다.

위와 같은 경우, 정의가 되지 않은 레퍼런스가 있는 것처럼 보이지만 실제로는 `change_val(number)` 가 실행될 때,
`int& p = number` 가 실행되는 형식이기에 문제가 없다.

만약 포인터였다면 `change_val(&number)` 라고 인자를 넣어야겠지만 레퍼런스는 그럴 필요가 없다는 것이다.

### 여러가지 참조자 예시들

```c++
#include <iostream>

int main() {
  int x;
  int& y = x;
  int& z = y;

  x = 1;
  std::cout << "x : " << x << " y : " << y << " z : " << z << std::endl;

  y = 2;
  std::cout << "x : " << x << " y : " << y << " z : " << z << std::endl;

  z = 3;
  std::cout << "x : " << x << " y : " << y << " z : " << z << std::endl;
}
```

```shell
# 실행 결과
x : 1 y : 1 z : 1
x : 2 y : 2 z : 2
x : 3 y : 3 z : 3
```

위와 같이 레퍼런스를 정의할 때 레퍼런스를 넣는 것도 가능하다.
어찌보면 당연한데 대입되는 레퍼런스는 본인이 가리키는 변수로 치환되기 때문이다.

그렇기에 `int&&` 와 같은 레퍼런스의 레퍼런스는 존재하지 않는다.

### 레퍼런스의 이점

레퍼런스의 기능들을 보면 모두 포인터로 구현할 수 있다. 그러나 레퍼런스를 사용하는 이유는 불필요한 `*` 과 `&` 를 생략할 수 있기 때문이다.
이는 훨씬 간결하게 코드를 짤 수 있으며 다양한 곧에서 사용될 수 있다.

예를 들어 `cin` 함수의 경우 `scanf` 와 다르게 주소값을 전달하지 않는다.
`cin` 이 주어진 변수의 값을 바꾸는 역할을 함에도 주소를 받지 않아도 되는 이유는 `cin` 이 레퍼런스를 받기 때문이다.
레퍼런스는 이러한 장점이 있다.

### 상수에 대한 참조자

```c++
#include <iostream>

int main() {
  int &ref = 4;

  std::cout << ref << std::endl;
}
```

위와 같은 코드는 컴파일에서 에러가 나게 된다. 왜냐하면 상수값 자체가 리터럴이기 때문이다.

> #### 리터럴(literal)
> 
> 리터럴이란 소스 코드 상에서 고정된 값을 가지는 것을 일컫는다. 그렇기에 리터럴은 읽기만 가능하고 변경이 불가하다.  
> 
> [literal 개념](https://modoocode.com/33)

만일 위와 같은 레퍼런스가 가능하다면 리터럴의 값을 바꾸는 행위 역시 가능해지기 때문에 C++ 문법 상 불가능하게 되어있다.

```c++
const int &ref = 4;
```

하지만 상수 레퍼런스로 선언한다면 리터럴을 참조할 수 있다.

### 레퍼런스의 배열과 배열의 레퍼런스

우선 레퍼런스의 배열은 C++ 규정 상, 불가능하다. 이유는 앞서 봤듯이 레퍼런스가 메모리 상의 주소를 가지고 있지 않기 때문이다.
C++ 상에서 배열의 이름은 첫 원소의 주소값으로 변환될 수 있어야 한다. 그러나 레퍼런스는 특별한 경우를 제외하고 메모리 상의 주소가 없기에 불가하다.

하지만 배열의 레퍼런스는 가능하다.

```c++
#include <iostream>

int main() {
  int arr[3] = {1, 2, 3};
  int(&ref)[3] = arr;

  ref[0] = 2;
  ref[1] = 3;
  ref[2] = 1;

  std::cout << arr[0] << arr[1] << arr[2] << std::endl;
  return 0;
}
```

```shell
# 실행 결과
231
```

위의 코드는 `ref[0]` ~ `ref[2]` 의 값들을 각각 `arr[0]` ~ `arr[2]` 의 레퍼런스가 된다.
이때, 배열의 레퍼런스는 반드시 배열의 크기를 명시해야 한다.

또한 아래와 같이 다차원 배열의 레퍼런스 역시 가능하다.

```c++
int arr[3][2] = {1, 2, 3, 4, 5, 6};
int (&ref)[3][2] = arr;
```

### 레퍼런스를 리턴하는 함수

```c++
int function() {
  int a = 2;
  return a;
}

int main() {
  int b = function();
  return 0;
}
```

위와 같은 코드에서  `int b = function();` 에선 다음과 같은 동작을 한다.

1. `function` 안에 정의된 `a` 라는 변수의 값이 `b` 에 복사된다.
2. `function` 이 종료되면 `a` 는 메모리에서 사라지게 된다.

#### 지역변수의 레퍼런스를 리턴

```c++
int& function() {
  int a = 2;
  return a;
}

int main() {
  int b = function();
  b = 3;
  return 0;
}
```

만약 레퍼런스를 반환하는 함수를 컴파일하면 경고가 나오고 실행 시, segmentation fault 에러가 생긴다.

이는 `function` 함수가 종료되면서 `a` 가 사라지며 생기는 문제이다.
즉, `b` 가 가지고 있는 레퍼런스가 가리키고 있는 `a` 가 사라진 것이다.

이와 같이 레퍼런스만 남아있고 원래 참조하던 것이 사라진 레퍼런스를 댕글링 레퍼런스(Dangling reference)라고 부른다.
그렇기에 위처럼 레퍼런스를 리턴하는 함수에서 지역 변수의 레퍼런스를 리턴하지 않도록 주의해야 한다.

#### 외부 변수의 레퍼런스를 리턴

```c++
int& function(int& a) {
  a = 5;
  return a;
}

int main() {
  int b = 2;
  int c = function(b);
  return 0;
}
```

위의 함수는 레퍼런스의 실체인 `b` 가 `main` 에 선언되어 있기에 레퍼런스는 잘 작동된다.
이는 결국 `c` 에 현재의 `b` 의 값인 5를 대입하는 것과 동일한 동작을 한다.

이러한 동작은 불필요해보이지만 효율적이다.
예를 들어 C언어에서 엄청나게 큰 구조체가 있을 때, 
해당 구조체 변수를 리턴하여 전체 복사하는 시간을 키우는 대신 해당 구조체를 가리키는 포인터를 리턴하면 포인터 주소 하나를 복사하므로 효율적이다.

이와 마찬가지로 레퍼런스를 리턴하게 되면 레퍼런스가 참조하는 타입의 크기와 상관없이 딱 한 번의 주소값 복사로 전달이 끝나게 된다.

#### 참조자가 아닌 값을 리턴하는 함수를 참조자로 받기

```c++
int function() {
  int a = 5;
  return a;
}

int main() {
  int& c = function();
  return 0;
}
```

위와 같이 함수가 리턴하는 값을 레퍼런스로 받는 경우 역시 컴파일 오류가 생긴다.

이는 앞선 댕글링 레퍼런스 문제와 마찬가지로 함수의 리턴값이 사라지기 때문이다.

허나 특별한 예외 역시 존재한다.

```c++
#include <iostream>

int function() {
  int a = 5;
  return a;
}

int main() {
  const int& c = function();
  std::cout << "c : " << c << std::endl;
  return 0;
}
```

위 코드의 차이점은 `const` 이다. 

원칙상 함수의 리턴값은 해당 문장이 끝나면 소멸되는 것이 맞다.
하지만 예외적으로 상수 레퍼런스로 리턴값을 받게 되면 해당 리턴값의 생명이 레퍼런스가 사라질 때까지 연장된다.

### 정리

|                                     | 함수에서 값 리턴(`int f()`) |      함수에서 참조자 리턴(`int& f()`)       |
|:-----------------------------------:|:--------------------:|:----------------------------------:|
|       값 타입으로 받음(`int a= f()`)       |        값 복사됨         | 값 복사됨, 다만 지역 변수의 레퍼런스를 리턴하지 않도록 주의 |
|     참조자 타입으로 받음(`int& a= f()`)      |        컴파일 오류        |  가능, 다만 지역 변수의 레퍼런스를 리턴하지 않도록 주의   |
| 상수 참조자 타입으로 받음(`const int& a= f()`) |          가능          | 가능, 다만 지역 변수의 레퍼런스를 리턴하지 않도록 주의 |


































